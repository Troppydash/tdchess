#pragma once#include <chrono>#include <utility>#include "../../lib/Fathom/src/tbprobe.h"#include "../helper.h"#include "../hpplib/chess.h"#include "cuckoo.h"#include "endgame.h"#include "evaluation.h"#include "features.h"#include "movegen.h"#include "nnue.h"#include "param.h"#include "rep.h"#include "see.h"#include "table.h"#include "time_control.h"#include "timer.h"#include "util.h"#include <iomanip>struct search_result{    std::vector<chess::Move> pv_line;    int32_t depth;    int16_t score;    [[nodiscard]] std::string get_score_uci() const    {        if (score > param::CHECKMATE)        {            int32_t ply = param::INF - score;            int mateIn = (ply / 2) + (ply % 2);            return std::string{"mate "} + std::to_string(mateIn);        }        if (score < -param::CHECKMATE)        {            int32_t ply = -param::INF - score;            int mateIn = (ply / 2) + (ply % 2);            return std::string{"mate "} + std::to_string(mateIn);        }        return std::string{"cp "} + std::to_string(score);    }    [[nodiscard]] std::string get_score() const    {        if (score > param::CHECKMATE)        {            int32_t ply = param::INF - score;            return std::string{"IN "} + std::to_string(ply) + " ply";        }        if (score < -param::CHECKMATE)        {            int32_t ply = -param::INF - score;            return std::string{"In "} + std::to_string(ply) + " ply";        }        std::stringstream stream;        stream << std::fixed << std::setprecision(2) << static_cast<double>(score) / 100;        return stream.str();    }};struct engine_stats{    int32_t nodes_searched;    int16_t tt_occupancy;    int32_t sel_depth;    std::chrono::milliseconds total_time;    void display_delta(const engine_stats &old, const search_result &result) const    {        long delta = (total_time - old.total_time).count();        uint32_t depth_nps = (nodes_searched - old.nodes_searched) * 1000 / std::max(1L, delta);        uint32_t nps =            nodes_searched * 1000 / std::max(static_cast<int64_t>(1), total_time.count());        printf("info depth %2d, nodes %10d, score %10s (%7d), nps %10d/%10d, moves", result.depth,               nodes_searched, result.get_score().c_str(), result.score, depth_nps, nps);        for (auto &m : result.pv_line)        {            std::cout << " " << chess::uci::moveToUci(m);        }        std::cout << std::endl;    }    long get_nps() const    {        return static_cast<long>(nodes_searched) * 1000 /               std::max(static_cast<int64_t>(1), total_time.count());    }    void display_uci(const search_result &result) const    {        std::cout << "info depth " << result.depth << " seldepth " << sel_depth << " multipv 1"                  << " score " << result.get_score_uci() << " nodes " << nodes_searched << " nps "                  << get_nps() << " time " << total_time.count() << " hashfull " << tt_occupancy                  << " pv";        for (auto &m : result.pv_line)        {            std::cout << " " << chess::uci::moveToUci(m);        }        std::cout << std::endl;    }};struct engine_param{    // default to zero reduction    int32_t lmr[param::MAX_DEPTH][100]{};    int32_t lmr_capture[param::MAX_DEPTH][100]{};    int16_t tempo = 10;    explicit engine_param()    {        // set lmr        for (int depth = 1; depth < param::MAX_DEPTH; ++depth)            for (int move = 1; move < 100; ++move)            {                lmr[depth][move] = std::floor(0.99 + std::log(depth) * std::log(move) / 3.14);                lmr_capture[depth][move] =                    std::floor(0.99 + std::log(depth) * std::log(move) / 3.6);            }    }};struct pv_line{    // pv_table[ply][i] is the ith pv move at ply    chess::Move pv_table[param::MAX_DEPTH][param::MAX_DEPTH]{};    // pv_length[ply] is the number of moves at ply    int pv_length[param::MAX_DEPTH]{};    explicit pv_line() = default;    void ply_init(int32_t ply)    {        pv_length[ply] = ply;    }    void update(int32_t ply, const chess::Move &move)    {        pv_table[ply][ply] = move;        for (int i = ply + 1; i < pv_length[ply + 1]; i++)            pv_table[ply][i] = pv_table[ply + 1][i];        pv_length[ply] = pv_length[ply + 1];    }    std::vector<chess::Move> get_moves()    {        std::vector<chess::Move> result(pv_length[0]);        for (int i = 0; i < pv_length[0]; ++i)        {            result[i] = pv_table[0][i];        }        return result;    }    void reset()    {        for (int &i : pv_length)            i = 0;    }};struct search_stack{    int32_t ply = 0;    int16_t static_eval = param::VALUE_NONE;    chess::Move move = chess::Move::NO_MOVE;    chess::Move excluded_move = chess::Move::NO_MOVE;    bool in_check = false;    bool tt_pv = false;    bool tt_hit = false;    std::array<chess::Move, param::QUIET_MOVES> quiet_moves{};    std::array<chess::Move, param::QUIET_MOVES> capture_moves{};    continuation_history *continuation = nullptr;    void reset(heuristics &heuristics)    {        ply = 0;        static_eval = param::VALUE_NONE;        move = chess::Move::NO_MOVE;        excluded_move = chess::Move::NO_MOVE;        in_check = false;        tt_pv = false;        tt_hit = false;        continuation =            &(heuristics.continuation[0][0][static_cast<uint8_t>(chess::Piece::NONE)][0]);    }};enum search_node_type{    NonPV,    PV,    Root};struct engine{    // current position    chess::Board m_position;    // global timer    timer m_timer;    // debug stats    engine_stats m_stats;    // constants    const engine_param m_param;    // tt    table *m_table;    // move ordering    std::unique_ptr<heuristics> m_heuristics = std::make_unique<heuristics>();    // pv-line    pv_line m_line;    // search stack    constexpr static int SEARCH_STACK_PREFIX = 10;    std::array<search_stack, param::MAX_DEPTH + SEARCH_STACK_PREFIX> m_stack;    // endgame table ref    endgame_table *m_endgame = nullptr;    // nnue ref    nnue *m_nnue = nullptr;    rep_filter m_filter{};    // must be set via methods    explicit engine(table *table) : engine(nullptr, nullptr, table)    {    }    explicit engine(endgame_table *endgame, nnue *nnue, table *table)        : m_stats(), m_table(table), m_endgame(endgame), m_nnue(nnue)    {        // init tables        if (m_nnue == nullptr)            pesto::init();        util::init();        cuckoo::init();    }    /**     * Setup the engine for a new position in the same game     */    void begin()    {        // update stats        auto reference_time = timer::now();        m_stats = engine_stats{0, 0, 0, timer::now() - reference_time};        // update age        assert(m_table != nullptr);        m_table->inc_generation();        // init nnue        if (m_nnue != nullptr)        {            m_nnue->initialize(m_position);        }        // reset move ordering variables        m_heuristics->begin();        // reset pvline        m_line.reset();        // reset stack        for (int i = SEARCH_STACK_PREFIX; i >= 0; --i)        {            m_stack[i].reset(*m_heuristics);            m_stack[i].ply = 0;        }        for (int i = 0; i < param::MAX_DEPTH; ++i)        {            m_stack[i + SEARCH_STACK_PREFIX].reset(*m_heuristics);            m_stack[i + SEARCH_STACK_PREFIX].ply = i;        }        m_filter.load(m_position);    }    [[nodiscard]] int evaluate_bucket() const    {        constexpr int n = 8;        constexpr int divisor = 32 / n;        return (m_position.occ().count() - 2) / divisor;    }    [[nodiscard]] int16_t evaluate() const    {        if (m_nnue != nullptr)        {            // max is 100            int phase = 2 * m_position.pieces(chess::PieceType::PAWN).count() +                        3 * m_position.pieces(chess::PieceType::KNIGHT).count() +                        3 * m_position.pieces(chess::PieceType::BISHOP).count() +                        5 * m_position.pieces(chess::PieceType::ROOK).count() +                        12 * m_position.pieces(chess::PieceType::QUEEN).count();            int32_t score = m_nnue->evaluate(m_position.sideToMove(), evaluate_bucket());            // taper to 70%            score = score * (230 + phase) / 330;            return score;        }        return pesto::evaluate(m_position) + m_param.tempo;    }    void make_move(const chess::Move &move, search_stack *ss)    {        ss->move = move;        m_filter.add(m_position);        if (move == chess::Move::NO_MOVE)        {            ss->continuation =                &(m_heuristics->continuation[0][0][static_cast<uint8_t>(chess::Piece::NONE)][0]);            m_position.makeNullMove();        }        else        {            assert(m_position.at(move.from()) < 12);            assert(move.to().index() < 64);            ss->continuation =                &(m_heuristics->continuation[ss->in_check][m_position.isCapture(move)]                                            [m_position.at(move.from())][move.to().index()]);            if (m_nnue != nullptr)                m_nnue->make_move(m_position, move);            m_position.makeMove(move);        }    }    void unmake_move(const chess::Move &move)    {        if (move == chess::Move::NO_MOVE)        {            m_position.unmakeNullMove();        }        else        {            m_position.unmakeMove(move);            if (m_nnue != nullptr)                m_nnue->unmake_move();        }        m_filter.remove(m_position);    }    template <bool is_pv_node> int16_t qsearch(int16_t alpha, int16_t beta, search_stack *ss)    {        const int32_t ply = ss->ply;        m_line.ply_init(ply);        if (is_pv_node)            m_stats.sel_depth = std::max(m_stats.sel_depth, ply + 1);        m_stats.nodes_searched += 1;        if ((m_stats.nodes_searched & 4095) == 0)            m_timer.check();        if (m_timer.is_stopped())            return 0;        if (ply >= param::MAX_DEPTH - 10)            return evaluate();        // draw check        if (m_position.isInsufficientMaterial() || m_filter.check(m_position, ply))            return get_contempt();        // 50 move limit        if (m_position.isHalfMoveDraw())        {            auto [_, type] = m_position.getHalfMoveDrawType();            if (type == chess::GameResult::DRAW)                return get_contempt();            return param::MATED_IN(ply);        }        if (alpha < get_contempt() && cuckoo::is_upcoming_rep(m_position, ply))        {            alpha = get_contempt();            if (alpha >= beta)                return alpha;        }        // [tt lookup]        uint64_t key = m_position.hash() ^ util::ZOBRIST_50MR[m_position.halfMoveClock()];        auto &bucket = m_table->probe(key);        bool bucket_hit = false;        auto &entry = bucket.probe(key, bucket_hit);        auto tt_result = entry.get(key, ply, param::QDEPTH, alpha, beta, bucket_hit);        ss->tt_hit = tt_result.hit;        tt_result.move =            ss->tt_hit && is_kinda_legal(tt_result.move) ? tt_result.move : chess::Move::NO_MOVE;        if (!is_pv_node && tt_result.can_use)        {            if (m_position.halfMoveClock() < 90)                return tt_result.score;        }        // [static evaluation]        int16_t best_score = -param::VALUE_INF;        int16_t futility_base = -param::VALUE_INF;        int16_t unadjusted_static_eval = param::VALUE_NONE;        ss->in_check = m_position.inCheck();        if (ss->in_check)        {            best_score = futility_base = -param::VALUE_INF;        }        else        {            if (ss->tt_hit)            {                unadjusted_static_eval = tt_result.static_eval;                if (!param::IS_VALID(unadjusted_static_eval))                    unadjusted_static_eval = evaluate();                ss->static_eval = best_score = to_corrected_static_eval(unadjusted_static_eval);                // use tt score to adjust static eval                bool bound_hit =                    tt_result.flag == param::EXACT_FLAG ||                    (tt_result.flag == param::BETA_FLAG && tt_result.score > best_score) ||                    (tt_result.flag == param::ALPHA_FLAG && tt_result.score < best_score);                if (param::IS_VALID(tt_result.score) && !param::IS_DECISIVE(tt_result.score) &&                    bound_hit)                {                    best_score = tt_result.score;                }            }            else            {                unadjusted_static_eval = evaluate();                ss->static_eval = best_score = to_corrected_static_eval(unadjusted_static_eval);            }            if (best_score >= beta)            {                if (!param::IS_DECISIVE(best_score))                {                    best_score += (beta - best_score) / 2;                }                if (!ss->tt_hit)                {                    bucket.store(key, param::BETA_FLAG, best_score, ply, param::UNSEARCHED_DEPTH,                                 chess::Move::NO_MOVE, unadjusted_static_eval, false,                                 m_table->m_generation);                }                return best_score;            }            if (best_score > alpha)                alpha = best_score;            futility_base = ss->static_eval + features::QSEARCH_FUT_OFFSET;        }        chess::Move prev_move = (ss - 1)->move;        int16_t score;        chess::Move best_move = chess::Move::NO_MOVE;        movegen gen{m_position,                    (*m_heuristics),                    tt_result.move,                    prev_move,                    ply,                    (ss - 1)->continuation,                    ss->in_check ? movegen_stage::EPV : movegen_stage::QPV};        chess::Move move;        int move_count = -1;        while ((move = gen.next_move()) != chess::Move::NO_MOVE)        {            move_count += 1;            if (!param::IS_LOSS(best_score))            {                // [fut prune]                // if (m_heuristics->is_capture(m_position, move) && !ss->in_check)                if (m_position.givesCheck(move) == chess::CheckType::NO_CHECK &&                    (ss - 1)->move != chess::Move::NO_MOVE && move.to() != (ss - 1)->move.to() &&                    !param::IS_LOSS(futility_base) && move.typeOf() != chess::Move::PROMOTION)                {                    if (move_count > 2)                        continue;                    auto captured = m_heuristics->get_capture(m_position, move);                    int16_t futility_value = futility_base + see::PIECE_VALUES[captured];                    if (futility_value <= alpha)                    {                        best_score = std::max(best_score, futility_value);                        continue;                    }                    if (!see::test_ge(m_position, move, alpha - futility_base))                    {                        best_score = std::max(best_score, std::min(futility_base, alpha));                        continue;                    }                }                // [see pruning]                if (!see::test_ge(m_position, move, features::QSEARCH_SEE_PRUNE))                    continue;            }            m_table->prefetch(key_after(move));            m_filter.prefetch(key_after(move));            make_move(move, ss);            score = -qsearch<is_pv_node>(-beta, -alpha, ss + 1);            unmake_move(move);            if (score > best_score)            {                best_score = score;                if (score > alpha)                {                    best_move = move;                    if (is_pv_node && !m_timer.is_stopped())                        m_line.update(ply, move);                    if (score >= beta)                        break;                    alpha = score;                }            }        }        // [mate check]        if (ss->in_check && move_count == -1)        {            return param::MATED_IN(ply);        }        // average out the best score        if (!param::IS_DECISIVE(best_score) && best_score > beta)            best_score += (beta - best_score) / 2;        // [draw check]        // if (move_count == -1)        // {        //     // we've explored all capture moves, only care about quiet moves        //     chess::Movelist moves;        //     chess::movegen::legalmoves<chess::movegen::MoveGenType::QUIET>(moves, m_position);        //     if (moves.empty())        //     {        //         best_score = get_contempt();        //     }        // }        if (!m_timer.is_stopped())        {            bucket.store(key, best_score >= beta ? param::BETA_FLAG : param::ALPHA_FLAG, best_score,                         ply, param::QDEPTH, best_move, unadjusted_static_eval,                         ss->tt_hit && ss->tt_pv, m_table->m_generation);        }        return best_score;    }    bool is_kinda_legal(const chess::Move &move) const    {        if (move.typeOf() == chess::Move::NO_MOVE)            return true;        auto moved_piece = m_position.at(move.from());        // from square check        if (moved_piece == chess::Piece::NONE || moved_piece.color() != m_position.sideToMove())            return false;        if (move.typeOf() != chess::Move::NORMAL)        {            // uncommon harder types just guess that it is fine            return true;            chess::PieceGenType moved_piece_gen;            if (moved_piece.type() == chess::PieceType::PAWN)                moved_piece_gen = chess::PieceGenType::PAWN;            else if (moved_piece.type() == chess::PieceType::KNIGHT)                moved_piece_gen = chess::PieceGenType::KNIGHT;            else if (moved_piece.type() == chess::PieceType::BISHOP)                moved_piece_gen = chess::PieceGenType::BISHOP;            else if (moved_piece.type() == chess::PieceType::ROOK)                moved_piece_gen = chess::PieceGenType::ROOK;            else if (moved_piece.type() == chess::PieceType::QUEEN)                moved_piece_gen = chess::PieceGenType::QUEEN;            else if (moved_piece.type() == chess::PieceType::KING)                moved_piece_gen = chess::PieceGenType::KING;            else                throw std::runtime_error{"impossible moved piece"};            chess::Movelist moves;            chess::movegen::legalmoves(moves, m_position, moved_piece_gen);            auto result = std::find(moves.begin(), moves.end(), move) != moves.end();            return result;        }        // end friendly piece check        if (m_position.at(move.to()).color() == m_position.sideToMove())            return false;        // chess::Movelist moves;        // chess::movegen::legalmoves(moves, m_position, moved_piece_gen);        // bool is_ok = std::find(moves.begin(), moves.end(), move) != moves.end();        // if (!is_ok)        // {        //     std::terminate();        //     // std::cout << "uh oh not legal move mate\n";        // }        // guess that it is fine        return true;    }    int16_t get_contempt() const    {        // TODO: contempt makes it worse for better engines, but better against worse engines        return 0;        int piece_count = m_position.occ().count();        constexpr int cutoff = 10;        if (piece_count <= cutoff)            return 0;        constexpr int16_t MAX_CONTEMPT = -15;        return static_cast<int16_t>((MAX_CONTEMPT * (piece_count - cutoff)) / (32 - cutoff));    }    uint64_t key_after(const chess::Move &move) const    {        int hfm = m_position.halfMoveClock();        if (m_position.isCapture(move))            hfm = 0;        else if (m_position.at(move.from()).type() == chess::PieceType::PAWN)            hfm = 0;        else            hfm += 1;        return m_position.zobristAfter<false>(move) ^ util::ZOBRIST_50MR[hfm];    }    template <bool is_pv_node>    int16_t negamax(int16_t alpha, int16_t beta, int32_t depth, search_stack *ss, bool cut_node)    {        // constants        const int32_t ply = ss->ply;        const chess::Move &prev_move = (ss - 1)->move;        m_line.ply_init(ply);        m_stats.nodes_searched += 1;        if ((m_stats.nodes_searched & 4095) == 0)            m_timer.check();        if (m_timer.is_stopped())            return 0;        if (ply >= param::MAX_DEPTH - 10)            return evaluate();        const bool is_root = ply == 0 && is_pv_node;        assert(!(ply == 0 && !is_pv_node));        assert(!(is_pv_node && cut_node));        assert(alpha < beta);        // [qsearch]        if (depth <= 0)        {            m_stats.nodes_searched -= 1;            return qsearch<is_pv_node>(alpha, beta, ss);        }        // check draw        if (!is_root && (m_position.isInsufficientMaterial() || m_filter.check(m_position, ply)))            return get_contempt();        // 50 move limit        if (!is_root && m_position.isHalfMoveDraw())        {            auto [_, type] = m_position.getHalfMoveDrawType();            if (type == chess::GameResult::DRAW)                return get_contempt();            return param::MATED_IN(ply);        }        // [mate distance pruning]        if (!is_root)        {            alpha = std::max(alpha, param::MATED_IN(ply));            beta = std::min(beta, param::MATE_IN(ply + 1));            if (alpha >= beta)                return alpha;        }        if (!is_root && alpha < get_contempt() && cuckoo::is_upcoming_rep(m_position, ply))        {            // {            //     bool draw = false;            //     chess::Movelist moves;            //     chess::movegen::legalmoves(moves, m_position);            //     for (auto &m : moves)            //     {            //         m_position.makeMove(m);            //         draw = m_position.isRepetition(1);            //         m_position.unmakeMove(m);            //         if (draw)            //             break;            //     }            //            //     if (!draw)            //         std::cout << "uh oh\n";            // }            alpha = get_contempt();            if (alpha >= beta)                return alpha;        }        // [tt lookup]        chess::Move &excluded_move = ss->excluded_move;        bool has_excluded = excluded_move != chess::Move::NO_MOVE;        uint64_t key = m_position.hash() ^ util::ZOBRIST_50MR[m_position.halfMoveClock()];        auto &bucket = m_table->probe(key);        bool bucket_hit = false;        auto &entry = bucket.probe(key, bucket_hit);        auto tt_result = entry.get(key, ply, depth, alpha, beta, bucket_hit);        ss->tt_hit = tt_result.hit;        ss->tt_pv = has_excluded ? ss->tt_pv : is_pv_node || (ss->tt_hit && tt_result.is_pv);        tt_result.move = ss->tt_hit && is_kinda_legal(tt_result.move) && !has_excluded                             ? tt_result.move                             : chess::Move::NO_MOVE;        bool is_tt_capture = tt_result.move != chess::Move::NO_MOVE &&                             m_heuristics->is_capture(m_position, tt_result.move);        // [tt early return]        if (!is_pv_node && tt_result.can_use && (cut_node == (tt_result.score >= beta)) &&            !has_excluded && tt_result.depth >= depth + (tt_result.score >= beta))        {            if (tt_result.move != chess::Move::NO_MOVE && tt_result.score >= beta)            {                // update history on cutoff                const int16_t main_history_bonus =                    (features::HISTORY_MULT * depth + features::HISTORY_BASE) / 2;                if (!m_heuristics->is_capture(m_position, tt_result.move))                {                    // don't store if early cutoff at low depth                    if (depth > features::HISTORY_EARLY_CUTOFF)                        m_heuristics->update_main_history(m_position, tt_result.move, ply,                                                          main_history_bonus);                    // [killer moves update]                    m_heuristics->store_killer(tt_result.move, ply, param::IS_WIN(tt_result.score));                    // [continuation history]                    update_continuation_history(ss, m_position.at(tt_result.move.from()),                                                tt_result.move.to(), main_history_bonus);                }                else                {                    m_heuristics->update_capture_history(m_position, tt_result.move,                                                         main_history_bonus);                }            }            // ignore tt for close to half move            if (m_position.halfMoveClock() < 90)                return tt_result.score;        }        // [tt evaluation fix]        int16_t unadjusted_static_eval = param::VALUE_NONE;        int16_t adjusted_static_eval = param::VALUE_NONE;        ss->in_check = m_position.inCheck();        if (ss->in_check)        {            ss->static_eval = adjusted_static_eval = param::VALUE_NONE;        }        else if (has_excluded)        {            unadjusted_static_eval = adjusted_static_eval = ss->static_eval;        }        else if (ss->tt_hit)        {            // weak beta cutoff on tt result            // if (!param::IS_DECISIVE(beta) && cut_node &&            //     tt_result.depth == depth - 1 && param::IS_VALID(tt_result.score)            //     && depth > 2)            // {            //     if (((tt_result.flag == param::BETA_FLAG || tt_result.flag == param::EXACT_FLAG)            //     &&            //          tt_result.score >= beta + 1000))            //     {            //         return tt_result.score;            //     }            // }            unadjusted_static_eval = tt_result.static_eval;            if (!param::IS_VALID(unadjusted_static_eval))                unadjusted_static_eval = evaluate();            ss->static_eval = adjusted_static_eval =                to_corrected_static_eval(unadjusted_static_eval);            // use tt score to adjust static eval            bool bound_hit =                tt_result.flag == param::EXACT_FLAG ||                (tt_result.flag == param::BETA_FLAG && tt_result.score > adjusted_static_eval) ||                (tt_result.flag == param::ALPHA_FLAG && tt_result.score < adjusted_static_eval);            if (param::IS_VALID(tt_result.score) && bound_hit)            {                adjusted_static_eval = tt_result.score;            }        }        else        {            unadjusted_static_eval = evaluate();            ss->static_eval = adjusted_static_eval =                to_corrected_static_eval(unadjusted_static_eval);            bucket.store(key, param::NO_FLAG, param::VALUE_NONE, ply, param::UNSEARCHED_DEPTH,                         chess::Move::NO_MOVE, unadjusted_static_eval, ss->tt_pv,                         m_table->m_generation);        }        // [check syzygy endgame table]        int16_t best_score = -param::VALUE_INF;        int16_t max_score = param::VALUE_INF;        if (m_endgame != nullptr && !has_excluded && !is_root && m_endgame->is_stored(m_position) &&            depth >= features::TB_HIT_DEPTH)        {            int16_t wdl = m_endgame->probe_wdl(m_position);            int16_t draw_score = 1;            int16_t tb_score = param::VALUE_SYZYGY - ply;            int16_t score = wdl < -draw_score  ? -tb_score                            : wdl > draw_score ? tb_score                                               : param::VALUE_DRAW + 2 * wdl * draw_score;            int8_t flag = wdl < -draw_score  ? param::ALPHA_FLAG                          : wdl > draw_score ? param::BETA_FLAG                                             : param::EXACT_FLAG;            if (flag == param::EXACT_FLAG ||                (flag == param::BETA_FLAG ? score >= beta : score <= alpha))            {                // int32_t new_depth = param::TB_DEPTH;                bucket.store(key, flag, score, ply, std::min(param::TB_DEPTH, depth + 7),                             chess::Move::NO_MOVE, unadjusted_static_eval, ss->tt_pv,                             m_table->m_generation);                return score;            }            if (is_pv_node)            {                if (flag == param::BETA_FLAG)                {                    best_score = score;                    alpha = std::max(alpha, score);                }                else                {                    max_score = score;                }            }        }        // improving flag        bool improving = true;        if (ss->in_check)            improving = false;        else if (param::IS_VALID((ss - 2)->static_eval) && param::IS_VALID(ss->static_eval))        {            improving = ss->static_eval > (ss - 2)->static_eval;        }        // else if (param::IS_VALID((ss - 4)->static_eval) && param::IS_VALID(ss->static_eval))        // {        //     improving = ss->static_eval > (ss - 4)->static_eval;        // }        if (ss->in_check)        {            goto moves;        }        // [razoring]        if (!is_pv_node && param::IS_VALID(adjusted_static_eval) &&            adjusted_static_eval <                alpha - features::RAZOR_BASE - features::RAZOR_DEPTH_MULT * depth * depth)        {            return qsearch<NonPV>(alpha, beta, ss);        }        // [static null move pruning]        {            int16_t margin = features::SNM_MARGIN * depth;            if (!ss->tt_pv && param::IS_VALID(adjusted_static_eval) &&                adjusted_static_eval - margin >= beta && !param::IS_LOSS(beta) && depth <= 14 &&                (tt_result.move == chess::Move::NO_MOVE || is_tt_capture) &&                !param::IS_WIN(adjusted_static_eval))            {                return (beta + adjusted_static_eval) / 2;            }        }        // [null move pruning]        {            const bool has_non_pawns = m_position.hasNonPawnMaterial(m_position.sideToMove());            if (cut_node && (ss - 1)->move != chess::Move::NO_MOVE && has_non_pawns &&                param::IS_VALID(ss->static_eval) && ss->static_eval >= beta - 30 * depth + 300 &&                !param::IS_LOSS(beta) && !has_excluded && depth >= features::NMP_DEPTH)            {                m_table->prefetch(key ^ chess::Zobrist::sideToMove());                m_filter.prefetch(key ^ chess::Zobrist::sideToMove());                int32_t reduction =                    features::NMP_REDUCTION_BASE + depth / features::NMP_REDUCTION_MULT;                // since nmp uses ss+1, we fake that this move is nothing                make_move(chess::Move::NO_MOVE, ss);                int16_t null_score =                    -negamax<false>(-beta, -beta + 1, depth - reduction, ss + 1, false);                unmake_move(chess::Move::NO_MOVE);                if (null_score >= beta && null_score < param::CHECKMATE)                {                    return beta;                }            }        }        // iir        if ((is_pv_node || cut_node) && depth >= 3 && tt_result.move == chess::Move::NO_MOVE)            depth -= 1;        // [prob cut]        // the score of a lower depth is likely similar to a score of higher depth        // goal is to convert beta to beta of a lower depth, and reject that        // we do move gen and eval using this first        {            // assume a 350 shift            int16_t probcut_beta = beta + features::PROBC_BETA_OFFSET;            if (!is_root && depth >= features::PROBC_DEPTH && !param::IS_DECISIVE(beta) &&                // also ignore when tt score is lower than expected beta                !(ss->tt_hit && param::IS_VALID(tt_result.score) &&                  tt_result.score < probcut_beta && tt_result.depth > depth - 3))            {                movegen gen{m_position, *m_heuristics, tt_result.move,                            prev_move,  ply,           movegen_stage::PROBPV};                chess::Move move;                int32_t probcut_depth =                    std::clamp(depth - features::PROBC_DEPTH_REDUCTION, 0, depth);                int16_t best_score = -param::INF;                int move_count = 0;                while ((move = gen.next_move()) != chess::Move::NO_MOVE)                {                    if (move == excluded_move)                        continue;                    move_count += 1;                    m_table->prefetch(key_after(move));                    m_filter.prefetch(key_after(move));                    make_move(move, ss);                    // check if move exceeds beta first                    int16_t score = -qsearch<false>(-probcut_beta, -probcut_beta + 1, ss + 1);                    // full search if qsearch null window worked                    if (score >= probcut_beta && probcut_depth > 0)                    {                        score = -negamax<false>(-probcut_beta, -probcut_beta + 1, probcut_depth,                                                ss + 1, !cut_node);                    }                    unmake_move(move);                    // check if can cut at lower depth                    if (score >= probcut_beta)                    {                        bucket.store(key, param::BETA_FLAG, score, ply, probcut_depth, move,                                     unadjusted_static_eval, ss->tt_pv, m_table->m_generation);                        return score - probcut_beta + beta;                    }                    if (score > best_score)                    {                        best_score = score;                    }                }                // iir idea                if (best_score < alpha - 600 && move_count > 3 && !param::IS_DECISIVE(alpha))                {                    depth -= 1;                }            }        }    moves:        // if (true)        // {        //     chess::Movelist actual_moves;        //     chess::movegen::legalmoves(actual_moves, m_position);        //        //     movegen gen{m_position, *m_heuristics, tt_result.move, prev_move, ply};        //     chess::Movelist found_moves;        //     chess::Move move;        //     while ((move = gen.next_move()) != chess::Move::NO_MOVE)        //     {        //         found_moves.add(move);        //     }        //        //     for (auto &m : actual_moves)        //     {        //         assert(std::find(found_moves.begin(), found_moves.end(), m) !=        //         found_moves.end());        //     }        //        //     for (auto &m : found_moves)        //     {        //         assert(std::find(actual_moves.begin(), actual_moves.end(), m) !=        //                actual_moves.end());        //     }        //        //     assert(!(actual_moves.size() > found_moves.size()));        //     assert(!(actual_moves.size() < found_moves.size()));        //        // }        std::array<const continuation_history *, NUM_CONTINUATION> conthist{            (ss - 1)->continuation, (ss - 2)->continuation, (ss - 3)->continuation,            (ss - 4)->continuation, (ss - 5)->continuation, (ss - 6)->continuation,        };        movegen gen{m_position, *m_heuristics, tt_result.move, prev_move, ply, conthist};        chess::Move best_move = chess::Move::NO_MOVE;        std::array<chess::Move, param::QUIET_MOVES> quiet_moves{};        std::array<chess::Move, param::QUIET_MOVES> capture_moves{};        // track quiet/capture moves for malus        int quiet_count = 0;        int capture_count = 0;        int move_count = -1;        chess::Move move;        while ((move = gen.next_move()) != chess::Move::NO_MOVE)        {            int32_t new_depth;            int32_t extension = 0;            int16_t score = 0;            int16_t capture_score = 0;            int16_t history_score = 0;            bool has_non_pawn = m_position.hasNonPawnMaterial(m_position.sideToMove());            if (move == excluded_move)                continue;            move_count += 1;            bool is_capture = m_heuristics->is_capture(m_position, move);            bool is_quiet = !is_capture;            // [low depth pruning]            if (!is_root && has_non_pawn && !param::IS_LOSS(best_score))            {                // [late move pruning], higher threshold if improving                if (move_count >= (3 + depth * depth) / (2 - improving))                    gen.skip_quiet();                int32_t lmr_depth = depth;                bool is_check = m_position.givesCheck(move) != chess::CheckType::NO_CHECK;                if (is_capture || is_check)                {                    auto captured = m_heuristics->get_capture(m_position, move);                    // [fut prune for captures]                    if (!is_check && lmr_depth < features::FUT_CAP_DEPTH_LIMIT &&                        param::IS_VALID(ss->static_eval))                    {                        int16_t capture_history = m_heuristics                                                      ->capture_history[m_position.at(move.from())]                                                                       [move.to().index()][captured]                                                      .get_value();                        int32_t fut_value = ss->static_eval + 300 + 300 * lmr_depth +                                            see::PIECE_VALUES[captured] + capture_history / 40;                        if (fut_value <= alpha)                            continue;                    }                    // [see pruning for captures and checks]                    // need to ensure that we don't prune: sac last non-pawn for stalemate                    auto non_pawn_pieces_sqs =                        m_position.pieces(chess::PieceType::KNIGHT, m_position.sideToMove()) |                        m_position.pieces(chess::PieceType::BISHOP, m_position.sideToMove()) |                        m_position.pieces(chess::PieceType::ROOK, m_position.sideToMove()) |                        m_position.pieces(chess::PieceType::QUEEN, m_position.sideToMove());                    auto moved_sq = chess::Bitboard(1ull << move.from().index());                    if (alpha >= param::VALUE_DRAW || non_pawn_pieces_sqs != moved_sq)                    {                        int16_t margin =                            features::SEE_CAP_BASE + features::SEE_CAP_DEPTH_MULT * depth;                        if (!see::test_ge(m_position, move, -margin))                            continue;                    }                }                else                {                    int32_t history =                        (*(ss - 1)->continuation)[m_position.at(move.from())][move.to().index()]                            .get_value();                    // [cont history pruning]                    if (history < -3000 * depth)                    {                        continue;                    }                    // [fut prune for general]                    if (!ss->in_check && lmr_depth < features::FUT_QUIET_DEPTH_LIMIT &&                        param::IS_VALID(ss->static_eval))                    {                        int32_t fut_value = ss->static_eval + features::FUT_QUIET_BASE +                                            features::FUT_QUIET_DEPTH_MULT * lmr_depth;                        if (fut_value <= alpha)                        {                            // shift best_score to fut value                            if (best_score < fut_value && !param::IS_DECISIVE(best_score) &&                                !param::IS_WIN(fut_value))                                best_score = fut_value;                            continue;                        }                    }                    // [see general pruning]                    int16_t margin = features::SEE_QUIET_BASE +                                     features::SEE_QUIET_DEPTH_MULT * lmr_depth * lmr_depth;                    if (!see::test_ge(m_position, move, -margin))                    {                        continue;                    }                }            }            new_depth = depth - 1;            m_table->prefetch(key_after(move));            m_filter.prefetch(key_after(move));            // [singular extension]            if (!has_excluded && tt_result.move == move && !is_root && tt_result.hit &&                param::IS_VALID(tt_result.score) && !param::IS_DECISIVE(tt_result.score) &&                (tt_result.flag == param::EXACT_FLAG || tt_result.flag == param::BETA_FLAG) &&                tt_result.depth >= depth - 3 && depth >= 5)            {                int32_t to_beat = tt_result.score - depth;                ss->excluded_move = move;                int16_t next_best_score =                    negamax<NonPV>(to_beat - 1, to_beat, (depth - 1) / 2, ss, cut_node);                ss->excluded_move = chess::Move::NO_MOVE;                if (next_best_score < to_beat)                {                    if (!is_pv_node && next_best_score < to_beat - 20)                        extension = 2;                    else                        extension = 1;                }                else if (next_best_score >= beta)                    return next_best_score;                else if (tt_result.score >= beta)                    // reduce if exact and tt score proved cutoff                    extension = -3 + ss->tt_pv;                else if (cut_node)                    extension = -2;            }            new_depth += extension;            if (is_quiet)            {                history_score = (m_heuristics->main_history)[m_position.sideToMove()]                                                            [move.from().index()][move.to().index()]                                                                .get_value();            }            else            {                capture_score =                    (m_heuristics->capture_history)[m_position.at(move.from())][move.to().index()]                                                   [m_heuristics->get_capture(m_position, move)]                                                       .get_value();            }            make_move(move, ss);            // [late move reduction]            if (depth >= 2 && move_count > 2 * is_root)            {                int32_t reduction = is_capture ? m_param.lmr_capture[depth][move_count]                                               : m_param.lmr[depth][move_count];                // extend if in check                reduction -= ss->in_check;                // reduce if not improving                reduction += !improving;                // reduce if in cut node                if (cut_node)                    reduction += 2 - ss->tt_pv;                // extend if pv                reduction -= ss->tt_pv + is_pv_node;                // reduce if tt capture                reduction += is_tt_capture;                // reduce/extend based on the history                if (is_quiet)                    reduction -= history_score / features::QUIET_LMR_DIV;                else                    reduction -= capture_score / features::CAPTURE_LMR_DIV;                int32_t reduced_depth = std::clamp(new_depth - reduction, 1, depth + 1);                score = -negamax<false>(-(alpha + 1), -alpha, reduced_depth, ss + 1, true);                if (score > alpha && reduced_depth < new_depth)                {                    // depth extend if score is good, reduce if score is bad                    new_depth += (score > best_score + features::RESEARCH_HIGH + new_depth * 2);                    new_depth -= (score < best_score + features::RESEARCH_LOW);                    if (reduced_depth < new_depth)                        score = -negamax<false>(-(alpha + 1), -alpha, new_depth, ss + 1, !cut_node);                }            }            else if (!is_pv_node || move_count > 0)            {                score = -negamax<false>(-(alpha + 1), -alpha, new_depth, ss + 1, !cut_node);            }            if (is_pv_node && (move_count == 0 || score > alpha))                score = -negamax<true>(-beta, -alpha, new_depth, ss + 1, false);            unmake_move(move);            if (score > best_score)            {                best_score = score;                if (score > alpha)                {                    best_move = move;                    if (is_pv_node && !m_timer.is_stopped())                        m_line.update(ply, best_move);                    if (score >= beta)                    {                        // [main history update]                        const int16_t main_history_bonus =                            features::HISTORY_MULT * depth + features::HISTORY_BASE;                        const int16_t main_history_malus =                            features::HISTORY_MALUS_MULT * depth + features::HISTORY_MALUS_BASE;                        if (!m_heuristics->is_capture(m_position, move))                        {                            // don't store if early cutoff at low depth                            if (depth > features::HISTORY_EARLY_CUTOFF || quiet_count > 0)                                m_heuristics->update_main_history(m_position, move, ply,                                                                  main_history_bonus);                            // malus apply                            for (int j = 0; j < quiet_count; ++j)                            {                                m_heuristics->update_main_history(m_position, quiet_moves[j], ply,                                                                  -main_history_malus);                            }                            // [killer moves update]                            m_heuristics->store_killer(move, ply, param::IS_WIN(score));                            // [continuation history]                            update_continuation_history(ss, m_position.at(move.from()), move.to(),                                                        main_history_bonus);                            // malus apply                            for (int j = 0; j < quiet_count; ++j)                            {                                update_continuation_history(                                    ss, m_position.at(quiet_moves[j].from()), quiet_moves[j].to(),                                    -main_history_malus);                            }                        }                        else                        {                            m_heuristics->update_capture_history(m_position, move,                                                                 main_history_bonus);                        }                        // malus apply                        for (int j = 0; j < capture_count; ++j)                        {                            m_heuristics->update_capture_history(m_position, capture_moves[j],                                                                 -main_history_malus);                        }                        break;                    }                    alpha = score;                }            }            // malus save            if (!m_heuristics->is_capture(m_position, move))            {                if (quiet_count < param::QUIET_MOVES)                    quiet_moves[quiet_count++] = move;            }            else            {                if (capture_count < param::QUIET_MOVES)                    capture_moves[capture_count++] = move;            }        }        // checkmate or draw        if (move_count == -1)        {            if (has_excluded)                best_score = alpha;            else if (ss->in_check)                best_score = param::MATED_IN(ply);            else                // draw                best_score = get_contempt();        }        if (is_pv_node)            best_score = std::min(best_score, max_score);        // if no good move found, last move good so add this one too        if (best_score <= alpha)            ss->tt_pv = ss->tt_pv || (ss - 1)->tt_pv;        if (!m_timer.is_stopped() && !has_excluded)        {            bucket.store(key,                         best_score >= beta                                ? param::BETA_FLAG                         : is_pv_node && best_move != chess::Move::NO_MOVE ? param::EXACT_FLAG                                                                           : param::ALPHA_FLAG,                         best_score, ply,                         move_count != -1 ? depth : std::min(param::MAX_DEPTH - 1, depth + 5),                         best_move, unadjusted_static_eval, ss->tt_pv, m_table->m_generation);        }        // update correction history        if (param::IS_VALID(ss->static_eval) && !ss->in_check &&            !(best_move != chess::Move::NO_MOVE && m_position.isCapture(best_move)) &&            (best_score > ss->static_eval) == (best_move != chess::Move::NO_MOVE) && depth >= 3 &&            !param::IS_DECISIVE(best_score))        {            int bonus = std::clamp((best_score - ss->static_eval) * depth / 8, -2000, 2000);            m_heuristics->update_corr_hist_score(m_position, bonus);        }        return best_score;    }    int16_t to_corrected_static_eval(int32_t static_eval) const    {        static_eval = (static_eval * static_cast<int32_t>(150 - m_position.halfMoveClock())) / 150;        int32_t value = 30 *                        m_heuristics                            ->correction_history[m_position.sideToMove()]                                                [m_heuristics->get_pawn_key(m_position) &                                                 PAWN_STRUCTURE_SIZE_M1]                            .get_value() /                        512;        value +=            35 *            m_heuristics                ->white_corrhist[m_position.sideToMove()]                                [m_heuristics->get_corrhist_key(m_position, chess::Color::WHITE) &                                 NON_PAWN_SIZE_M1]                .get_value() /            512;        value +=            35 *            m_heuristics                ->black_corrhist[m_position.sideToMove()]                                [m_heuristics->get_corrhist_key(m_position, chess::Color::BLACK) &                                 NON_PAWN_SIZE_M1]                .get_value() /            512;        static_eval += value;        return std::clamp((int)static_eval, -param::NNUE_MAX, (int)param::NNUE_MAX);    }    void update_continuation_history(search_stack *ss, chess::Piece piece, chess::Square to,                                     int bonus)    {        constexpr std::array<int16_t, NUM_CONTINUATION> weights{1100, 800, 100, 400, 70, 300};        for (int i = 1; i <= NUM_CONTINUATION; ++i)        {            if ((ss - i)->continuation != nullptr)            {                assert(piece < 12);                assert(to.index() < 64);                if (ss->in_check && i > 2)                    break;                (*(ss - i)->continuation)[piece][to.index()].add_bonus(bonus * weights[i - 1] /                                                                       1024);            }        }    }    uint64_t perft(int depth)    {        chess::Movelist moves;        chess::movegen::legalmoves(moves, m_position);        if (depth == 1)        {            return moves.size();        }        uint64_t total = 0;        for (const auto &move : moves)        {            m_position.makeMove(move);            total += perft(depth - 1);            m_position.unmakeMove(move);        }        return total;    }    void perft(const chess::Board &reference, int depth)    {        using namespace std;        m_position = reference;        cout << "benchmarking perft, depth: " << depth << endl;        cout << "fen: " << m_position.getFen() << endl;        const auto t1 = chrono::high_resolution_clock::now();        const auto nodes = perft(depth);        const auto t2 = chrono::high_resolution_clock::now();        const auto ms = chrono::duration_cast<chrono::milliseconds>(t2 - t1).count();        auto original = std::cout.getloc();        std::cout.imbue(std::locale("en_US.UTF-8"));        cout << "nodes: " << nodes << ", took " << ms << "ms" << endl;        cout << "nps: " << nodes * 1000 / std::max(static_cast<int64_t>(1), ms) << endl;        std::cout.imbue(original);    }    search_result search(const chess::Board &reference, search_param &param, bool verbose = false)    {        // timer info first        const auto control = param.time_control(reference.fullMoveNumber(), reference.sideToMove());        if (verbose)            std::cout << "info searchtime " << control.time << std::endl;        m_timer.start(control.time);        auto reference_time = timer::now();        m_position = reference;        begin();        search_result result{};        if (m_endgame != nullptr && m_endgame->is_stored(m_position))        {            // root search            auto probe = m_endgame->probe_dtm(m_position, m_timer);            result.pv_line = probe.first;            result.depth = result.pv_line.size();            result.score = probe.second;            if (verbose)            {                m_stats.display_uci(result);            }            return result;        }        for (int32_t depth = 1; depth <= std::min(param::MAX_DEPTH - 10, control.depth); depth += 1)        {            // scale window by score, larger scores warrants higher window            int window = 25 + result.score * result.score / 13000;            int alpha = -param::INF;            int beta = param::INF;            if (depth >= 3)            {                alpha = std::max(-param::INF, result.score - window);                beta = std::min((int)param::INF, result.score + window);            }            int32_t score = 0;            while (true)            {                score = negamax<true>(alpha, beta, depth, &m_stack[SEARCH_STACK_PREFIX], false);                if (m_timer.is_stopped())                    break;                if (score <= alpha)                {                    beta = (alpha + beta) / 2;                    alpha = std::max(-param::INF, score - window);                }                else if (score >= beta)                {                    alpha = (alpha + beta) / 2;                    beta = std::min((int)param::INF, score + window);                }                else                {                    // only update score on exact scores                    result.score = score;                    break;                }                window += window / 2;            }            // update lines always, since root moves are updated only when timer ok            if (!m_line.get_moves().empty())            {                result.pv_line.clear();                result.pv_line = m_line.get_moves();            }            // depth is whatever            result.depth = depth;            // optimum time check, after asp window re-search            if (m_timer.is_delta(control.opt_time))                break;            // display info            m_stats.total_time = timer::now() - reference_time;            m_stats.tt_occupancy = m_table->occupied();            if (verbose)            {                m_stats.display_uci(result);            }            // check if just one move            if (depth == 1)            {                chess::Movelist moves;                chess::movegen::legalmoves(moves, m_position);                if (moves.size() == 1)                    break;            }        }        // final log        m_stats.total_time = timer::now() - reference_time;        m_stats.tt_occupancy = m_table->occupied();        if (verbose)        {            m_stats.display_uci(result);        }        return result;    }};